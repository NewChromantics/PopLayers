<html>
<head>
<title>Pop Layers</title>
<style>

canvas
{
	width:	256px;
	height:	256px;
}


</style>

</head>
<body>


<img src=Cat256.jpg id=CatJpeg />
<canvas id=OutputStaticDepth width=256 height=256></canvas>
<canvas id=InputVideo width=256 height=256></canvas>
<canvas id=OutputDepth width=256 height=256></canvas>


<script type="module">

import {GenerateDepth} from './GenerateDepth/GenerateDepth.js'
import {VideoDecoder} from './PopEngine/Video.js'

function GetImageDataFromHtmlImageElement(Img,UseCanvas,OutputSize)
{
	function GetPixelsMetaFromHtmlImageElement(Img)
	{
		const Meta = {};
		Meta.Width = Img.videoWidth || Img.width || Img.displayWidth;
		Meta.Height = Img.videoHeight || Img.height || Img.displayHeight;
		Meta.Format = 'RGBA';
		return Meta;
	}

	//	html5 image
	//if ( Img.constructor == WebApi_HtmlImageElement )
	{
		//	gr: is this really the best way :/
		const Canvas = UseCanvas || document.createElement('canvas');
		const Context = Canvas.getContext('2d');
		const ImgMeta = GetPixelsMetaFromHtmlImageElement(Img);
		const Width = OutputSize ? OutputSize[0] : ImgMeta.Width;
		const Height = OutputSize ? OutputSize[1] : ImgMeta.Height;
		Canvas.width = Width;
		Canvas.height = Height;
		//	stretch to fill canvas
		Context.drawImage( Img, 0, 0, Canvas.width, Canvas.height );
		const ImageData = Context.getImageData(0, 0, Width, Height);
		
		if ( !UseCanvas )
		{
			//	destroy canvas (safari suggests its hanging around)
			Canvas.width = 0;
			Canvas.height = 0;
			//delete Canvas;	//	not allowed in strict mode
			//Canvas = null;
		}
		
		return ImageData;
	}
}


function GetPixelsFromHtmlImageElement(Img,UseCanvas)
{
	const ImageData = GetImageDataFromHtmlImageElement(Img,UseCanvas);
	
	const Buffer = ImageData.data;
		
	const Pixels = {};
	Pixels.Width = Width;
	Pixels.Height = Height;
	Pixels.Buffer = Buffer;
	//	gr: I checked pixels manually, canvas is always RGBA [in chrome]
	Pixels.Format = 'RGBA';
		
	return Pixels;
}

async function DrawToCanvas(Canvas,Image)
{
	const Context = Canvas.getContext('2d');

	if ( Image instanceof ImageData )
	{
		Context.putImageData( Image, 0, 0 );
	}
	else
	{
		let Width = Canvas.width || Image.width || Image.displayWidth;
		let Height = Canvas.height || Image.height || Image.displayHeight;
		//	stretches!
		Context.drawImage( Image, 0, 0, Width, Height );
	}
}

async function GenerateDepthAndDrawToCanvas(Canvas,Image)
{
	const Depth = await GenerateDepth(Image);
	
	//	turn depth data into rgba buffer for canvas	
	const Context = Canvas.getContext('2d');
	const RgbaPixels = Context.createImageData( Depth.Width, Depth.Height );
	function DepthPixelToDepthRgba(p,Index)
	{
		p -= Depth.MinValue;
		p /= Depth.MaxValue - Depth.MinValue;
		p *= 255;
		const Rgba = [p,p,p,255];
		const RgbaIndex = Index * 4;
		RgbaPixels.data[RgbaIndex+0] = Rgba[0];
		RgbaPixels.data[RgbaIndex+1] = Rgba[1];
		RgbaPixels.data[RgbaIndex+2] = Rgba[2];
		RgbaPixels.data[RgbaIndex+3] = Rgba[3];
	}
	Depth.Pixels.forEach( DepthPixelToDepthRgba );
	
	await DrawToCanvas(Canvas,RgbaPixels);
	
	return RgbaPixels;
}

import {FetchArrayBufferStream} from './PopEngine/FileSystem.js'

async function VideoThread()
{
	const VideoUrl = `Cat3.mp4`;
	const Video = new VideoDecoder( VideoUrl );
	const OutputCanvas = document.querySelector(`#OutputDepth`);
	const InputCanvas = document.querySelector(`#InputVideo`);

	//const OutputVideo = new VideoEncoder();

	async function DownloadThread()
	{
		function OnProgress(Chunks)
		{
			const LastChunk = Chunks.slice(-1)[0];
			Video.PushData(LastChunk);
		}
		await FetchArrayBufferStream(VideoUrl,OnProgress);
		
	}
	DownloadThread();

	while ( true )
	{
		const NextFrame = await Video.WaitForNextFrame();
		if ( !NextFrame )
			break;
		//await DrawToCanvas( InputCanvas, NextFrame.Data );
		const OutputSize = [256,256];
		const FramePixels = GetImageDataFromHtmlImageElement( NextFrame.Data, null, OutputSize );
		await DrawToCanvas( InputCanvas, FramePixels );
		const DepthPixels = await GenerateDepthAndDrawToCanvas( OutputCanvas, FramePixels );
		
		//OutputVideo.encode(DepthPixels);
		
		if ( NextFrame.Free )
			NextFrame.Free();
		else if ( NextFrame.Data.Free )
			NextFrame.Data.Free();
	}
}
//VideoThread();

async function Bootup()
{
	const CatImg = document.querySelector(`#CatJpeg`);
	const OutputCanvas = document.querySelector(`#OutputStaticDepth`);
	await GenerateDepthAndDrawToCanvas(OutputCanvas,CatImg).catch(console.error);

	await VideoThread();
}
Bootup();

</script>

</body>
</html>
