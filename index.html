<html>
<head>
<title>Pop Layers</title>
<script src="./WebComponent_TreeView/TreeView.js" type=module></script>
<style>

canvas
{
	width:	256px;
	height:	256px;
}

:root
{
	--ChequerBoardSize:		15px;
	--ChequerBoardColourA:	#ccf;/*#89d;*/
	--ChequerBoardColourB:	#eee;/*#cce;*/
	--ChequerBoardBackground:		repeating-conic-gradient( var(--ChequerBoardColourA) 0% 25%, var(--ChequerBoardColourB) 0% 50%) 50% / var(--ChequerBoardSize) var(--ChequerBoardSize);

}

body
{
	--Spacing:	1em;
	
	background:	#333;
	padding:	0px;
	margin:		var(--Spacing);

	/* stretch grid to fill */
	height:		100vh;
	
	display:	grid;
	grid-template-areas:	"ProjectList ProjectList"
							"Workspace Thumbnails"
							;
	grid-template-columns:	1.0fr 0.3fr;
	align-items:		normal;
	justify-items:		normal;
	
	grid-column-gap:	var(--Spacing);
	grid-row-gap:		var(--Spacing);
}

#Workspace
{
	display:	grid;
	grid-template-areas:	"Error"
							"Progress"
							"Preview"
							"Uniforms"
							;
	grid-template-rows:		0.0fr 2em 1fr 2fr;
}

#Preview
{
	background:	var(--ChequerBoardBackground);
	
	grid-area:	Preview;
	min-height:	10vh;
}

#Uniforms
{
	background:	#eee;
	grid-area:	Uniforms;
	min-height:	10vh;
	display:	block;
}

#Thumbnails
{
	overflow:	auto;
	background:	#eee;
	
	display:	flex;
	flex-direction:	column;
	flex-wrap:		nowrap;
}


#Thumbnails > *
{
	xdisplay:	block;
	width:		100%;
	min-height:	3em;
	display:	block;
	padding:	0em;
	margin:		0em;
	
	background:	var(--ChequerBoardBackground);
}

#Thumbnails #LayerTree
{
	flex:		1;
}
/*
#Thumbnails img[selected]
{
	border:		2px solid red;
}

#Thumbnails > div *
{
	display:	block;
}

#Thumbnails > div span
{
	pointer-events:	none;
}

#Thumbnails > div
{
	border:		dashed 1px #000;
	padding:	1em;
	
	display:	grid;
	align-items:		center;
	justify-items:		center;
}
*/
#Progress
{
	grid-area:	Progress;
	background:	#ff0;
	padding:	1em;
}

#InputVideo
{
	grid-area:	InputVideo;
	background:	#efe;
	padding:	1em;
}

#OutputDepth
{
	grid-area:	OutputDepth;
	background:	#ffe;
	padding:	1em;
}

#Error,
#Info
{
	display:	block;
	grid-area:	Error;
	background:	#d33;
	color:		#fff;
	border:		1px solid #fff;
	padding:	0.5em;
	margin:		1em;
}

#Info
{
	grid-area:	Info;
	background:	#3d3;
}

#Error:empty,
#Info:empty
{
	display:	none;
}

#ProjectList
{
	grid-area:	ProjectList;
	background:	black;
	min-height:	2em;
	display:	grid;
	grid-template-columns: repeat(auto-fill, minmax(8em, 1fr));
	grid-gap:	1em;
}

#ProjectList > *
{
	display:	inline-block;
	background:	white;
	padding:	0.5em;
}


#ProjectList > *[Active]
{
	background:	red;
}

</style>

</head>
<body>

<script>
	var QueueNewVideoFunction = function(){	throw `QueueNewVideoFunction not assigned`;	};
	var OnAddFragLayer = function(){	throw `OnAddFragLayer not assigned`; };
	var OnAddDepthEstimateLayer = function(){	throw `OnAddDepthEstimateLayer not assigned`; };
	var OnAddImageLayer = function(){	throw `OnAddImageLayer not assigned`; };
	var OnLoadProject = function(){	throw `OnLoadProject not assigned`; };
	
	function LoadCatMp4()
	{
		QueueNewVideoFunction(`Cat2.mp4`);
	}
	
	function SetProgress(FrameCompleted,FrameCount)
	{
		const Div = document.querySelector(`#Progress`);
		const Text = `${FrameCompleted}/${FrameCount}`;
		Div.innerText = Text;
	}
	
	function OnError(Error)
	{
		const Div = document.querySelector(`#Error`);
		const Text = Error ? `${Error}` : '';
		Div.innerText = Text;
	}
	
	function GetLayerThumbnailImages()
	{
		return Array.from( document.querySelectorAll(`#Thumbnails img`) );
	}

	function SelectNoLayer()
	{
		SelectThumbnailElement( null, null );
	}

	function SelectThumbnailElement(Element,Index=null)
	{
		const ThumbnailsDiv = document.querySelector(`#Thumbnails`);
		
		let LayerThumbnailImages = GetLayerThumbnailImages();
		LayerThumbnailImages.forEach( img => img.removeAttribute('selected') );
		
		if ( Element )
			Element.setAttribute('selected',true);
		
		if ( ThumbnailsDiv.OnSelectionChanged )
			ThumbnailsDiv.OnSelectionChanged(Index);
	}
	
	function ClearLayerThumbnails()
	{
		const Thumbnails = GetLayerThumbnailImages();
		Thumbnails.forEach( t => t.parentElement.removeChild(t) );
		SelectNoLayer();
	}
	
	function GetLayerThumbnailElement(LayerIndex)
	{
		const ThumbnailsDiv = document.querySelector(`#Thumbnails`);
		
		let LayerThumbnailImages = GetLayerThumbnailImages();
		
		//	add images to document if some are missing
		while ( LayerIndex >= LayerThumbnailImages.length )
		{
			const NewImageIndex = LayerThumbnailImages.length;
			let NewImage = document.createElement('img');
			NewImage.onclick = () => SelectThumbnailElement(NewImage,NewImageIndex);

			ThumbnailsDiv.appendChild( NewImage );
			LayerThumbnailImages = GetLayerThumbnailImages();
		}
		
		return LayerThumbnailImages[LayerIndex];
	}
	
	function AddFragLayer()
	{
		OnAddFragLayer();
	}
	
	function AddDepthEstimateLayer()
	{
		OnAddDepthEstimateLayer();
	}
	
	function AddImageLayer()
	{
		OnAddImageLayer();
	}
	
	function LoadProject(ProjectName)
	{
		OnLoadProject(ProjectName);
	}
	
	function UpdateProjectButtons(ProjectNames)
	{
		const ProjectListElement = document.querySelector(`#ProjectList`);
		let ProjectButtons = Array.from( document.querySelectorAll(`#ProjectList > button`) );
		let NewProjectNames = ProjectNames.filter( Name => !ProjectButtons.find( b => b.ProjectName == Name ) );
		
		for ( let ProjectName of NewProjectNames )
		{
			let Button = document.createElement('button');
			Button.ProjectName = ProjectName;
			Button.onclick = () => LoadProject( ProjectName );
			Button.innerText = ProjectName;//	label
			ProjectListElement.insertBefore( Button, ProjectListElement.firstChild );
		}
	}
	
	function SetProjectButtonActive(Name,Active=true)
	{
		if ( !Name )
			return;
			
		let ProjectButtons = Array.from( document.querySelectorAll(`#ProjectList > button`) );
		ProjectButtons = ProjectButtons.filter( b => b.ProjectName != null );
		const ProjectButton = ProjectButtons.find( b => b.ProjectName == Name );
		
		//	currently NOT auto turning off other buttons, to prove logic is correct for shutting them down
		if ( !ProjectButton )
			throw `Missing project button for ${Name}`;
		
		if ( Active )
			ProjectButton.setAttribute('Active',true);
		else
			ProjectButton.removeAttribute('Active');
	}
	
</script>

<div id=ProjectList>
	<button id=NewProject onclick="LoadProject(null)">+ Create New Project</button>
</div>

<div id=Workspace>
	<div id=Error></div>
	<div id=Progress>0/0</div>
	<canvas id=Preview></canvas>
	<tree-view id=Uniforms json='' css="WebComponent_TreeView/TreeView.css"></tree-View>
</div>

<div id=Thumbnails>
	<div class=AddLayerBox>
		<span>Add new frag layer</span>
		<button onclick="AddFragLayer()">Add Frag Layer</button>
	</div>
	<div class=AddLayerBox>
		<span>Add depth estimate layer</span>
		<button onclick="AddDepthEstimateLayer()">Add Depth Estimate Layer</button>
	</div>
	<div class=AddLayerBox>
		<span>Add image layer</span>
		<button onclick="AddImageLayer()">Add image/video Layer</button>
	</div>
	<tree-view css="LayerTree.css" id=LayerTree></tree-view>
</div>

<script type="module">


import LayerManager_t from './LayerManager.js'
import LayerFrag from './LayerFrag.js'
import LayerDepthEstimate from './LayerDepthEstimate.js'
import LayerImage from './LayerImage.js'
import {Yield} from './PopEngine/PopWebApiCore.js'
import {LoadFilePromptAsArrayBufferAsync} from './PopEngine/FileSystem.js'

//	dont reference CurrentLayerManager directly
let CurrentLayerManager;
let CurrentProjectName = null;


function GetCurrentLayerManager()
{
	return CurrentLayerManager;
}

function UpdateLayerUi()
{
	const LayerManager = GetCurrentLayerManager();
	const LayerTree = document.querySelector(`#LayerTree`);
	//	generate tree
	const Tree = {};
	const Meta = {};
	
	Meta['_root'] = { Droppable:true };
	
	//	gr: this should probably be using GetStructure()
	for ( let l=0;	l<LayerManager.Layers.length;	l++ )
	{
		const LayerName = LayerManager.GetLayerName(l);
		Tree[LayerName] = {};
		Meta[LayerName] = {};
		Tree[LayerName].Name = LayerName;
		Tree[LayerName].Thumbnail = {};
		
		Meta[LayerName] = { KeyAsLabel:'Name', Deletable: true, Draggable:true, Selectable:true };
		//Meta[LayerName].ElementType = 'img';
		Meta[LayerName+'.Thumbnail'] = { ElementType:'img',style:'pointer-events:none' };
		Meta[LayerName+'.Name'] = { Visible:false };
	}
	
	LayerTree.rootMeta = {Droppable:true};
	LayerTree.meta = Meta;
	LayerTree.json = Tree;
}

function SetProjectActive(ProjectName,LayerManager)
{
	//	close old project
	//SetProjectButtonActive( CurrentProjectName, false );
	CurrentLayerManager = null;
	CurrentProjectName = null;
	
	//	set new one
	CurrentLayerManager = LayerManager;
	CurrentProjectName = ProjectName;
	SaveLastActiveProject(ProjectName);
	SetProjectButtonActive( ProjectName );
	ClearLayerThumbnails();	
}

function IsProjectActive(ProjectName)
{
	return CurrentProjectName == ProjectName;
}


//	bind UI
OnAddFragLayer = function()
{
	const Layer = new LayerFrag();
	GetCurrentLayerManager().InsertLayer( Layer );
}
OnAddDepthEstimateLayer = function()
{
	const Layer = new LayerDepthEstimate();
	GetCurrentLayerManager().InsertLayer( Layer );
}
OnAddImageLayer = async function()
{
	const ImageFile = await LoadFilePromptAsArrayBufferAsync("Image file");
	const Layer = new LayerImage();
	await Layer.LoadFile( ImageFile );
	GetCurrentLayerManager().InsertLayer( Layer );
}
OnLoadProject = async function(ProjectName)
{
	//	should do this in an app thread really so we dont interrupt anything or get race conditions
	SetProjectActive(null);
	
	//	give threads a chance to clean up here
	await Yield(0);
	
	//	generate new project name
	if ( !ProjectName )
	{
		ProjectName = window.prompt(`Enter new project name`, `Project`);
	}
	
	//	start new thread
	LayerManagerThread(ProjectName);
}

function SetupThumbnailUi()
{
	const ThumbnailsDiv = document.querySelector(`#Thumbnails`);
	const UniformsElement = document.querySelector(`#Uniforms`);
	
	async function UpdateUniforms(NewUniforms,LayerIndex)
	{
		let Index = LayerIndex;
		const Layer = GetCurrentLayerManager().GetLayer(Index);
		await Layer.SetUniforms(NewUniforms);
		GetCurrentLayerManager().OnLayerChanged(Layer,`Changed uniforms`);
	}
	
	function OnLayerSelected(Index)
	{
		UniformsElement.onchange = null;
		
		if ( Index === null )
		{
			UniformsElement.meta = {};
			UniformsElement.json = {};
		}
		else
		{
			const Layer = GetCurrentLayerManager().GetLayer(Index);
			const LayerUniforms = Layer.GetUniforms();
			const LayerUniformMeta = Layer.GetUniformMetas();
			UniformsElement.meta = LayerUniformMeta;
			UniformsElement.json = LayerUniforms;
			
			UniformsElement.onchange = (NewUniforms) => UpdateUniforms( NewUniforms, Index ); 
		}
	}
	ThumbnailsDiv.OnSelectionChanged = OnLayerSelected;
}
SetupThumbnailUi();

const LastActiveProjectKey = '_LastActiveProject';
async function SaveLastActiveProject(ProjectName)
{
	window.localStorage.setItem(LastActiveProjectKey,ProjectName);
}

async function GetProjectNames()
{
	let StoredKeys = Object.keys( window.localStorage );
	
	let LastProjectName = window.localStorage.getItem(LastActiveProjectKey);
	StoredKeys = StoredKeys.filter( k => k!=LastActiveProjectKey );
	
	function Compare_LastProjectFirst(a,b)
	{
		if ( a == LastProjectName )	return -1;
		if ( b == LastProjectName )	return 1;
		return 0;
	}
	StoredKeys.sort(Compare_LastProjectFirst);
	
	return StoredKeys;
}

async function LoadFromLocalStorage(LayerManager,ProjectName)
{
	const StructureJson = window.localStorage.getItem(ProjectName);
	if ( !StructureJson )
		return false;
	
	const Structure = JSON.parse( StructureJson );
	LayerManager.LoadStructure(Structure,`LocalStorage`);
	return true;
}

async function SaveToLocalStorage(LayerManager,ProjectName)
{
	if ( !ProjectName )
		throw `SaveToLocalStorage invalid name ${ProjectName}`;
		
	//	should switch to indexedDB once we need to store blobs (images probably)
	//	https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API
	const Structure = await LayerManager.GetStructure();
	//	todo: convert back to make sure we haven't lost anything in translation?
	const StructureJson = JSON.stringify( Structure );
	const IsNewItem = window.localStorage.getItem(ProjectName)==null;
	window.localStorage.setItem(ProjectName,StructureJson);
	
	//	update ui in case we wrote a new project
	if ( IsNewItem )
	{
		const ProjectNames = await GetProjectNames();
		UpdateProjectButtons( ProjectNames );
	}
}

const DefaultFragShader = `precision highp float;
varying vec2 FragUv;
uniform float FrameTimeMs;
uniform float StripeCount; // {min:1,max:100,default:50}
void main()
{
	float TimeNorm = fract( FrameTimeMs / 1000.0);
	gl_FragColor = vec4( FragUv, 0, 0.5 );
	float Stripe = length(FragUv - vec2(0.5));
	Stripe *= StripeCount;
	Stripe = fract(Stripe);
	gl_FragColor.z = abs(Stripe-TimeNorm) < 0.2 ? 0.0 : 1.0;
	gl_FragColor.w = max( gl_FragColor.z, gl_FragColor.w );
}
`;

async function LayerManagerThread(ProjectName)
{
	if ( !ProjectName )
		throw `Invalid project name for layer thread ${ProjectName}`;
	const Canvas = document.querySelector(`#Preview`);
	let LayerManager = new LayerManager_t(Canvas);

	
	//	load project
	if ( !await LoadFromLocalStorage(LayerManager,ProjectName) )
	{
		//	is a new project, add a default layer
		//OnAddFragLayer();
		const Layer0 = new LayerFrag();
		Layer0.Frag = DefaultFragShader;
		LayerManager.InsertLayer( Layer0, 0 );
	}
	
	await SaveToLocalStorage( LayerManager, ProjectName );
	SetProjectActive( ProjectName, LayerManager );

	UpdateLayerUi();

	function IsThisProjectActive()
	{
		return IsProjectActive( ProjectName );
	}
	
	async function SaveLayerManagerThread()
	{
		while ( IsThisProjectActive() )
		{
			await LayerManager.WaitForStructureChange();
			UpdateLayerUi();
			
			try
			{
				await SaveToLocalStorage( LayerManager, ProjectName );
			}
			catch(e)
			{
				console.error(e);
			}
		}
	}

	async function OnLayerImage(LayerIndex,Image)
	{
		if ( !Image )
			return;
			
		//	update tree view json
		const LayerTree = document.querySelector(`#LayerTree`);
		let TreeJson = LayerTree.json;
		let JsonChanged = false;
		
		const LayerName = LayerManager.GetLayerName(LayerIndex);
		for ( let LayerNodeName in TreeJson )
		{
			if ( LayerNodeName != LayerName )
				continue;
			
			const ImageUrl = await Image.GetDataUrlScaled(0.1);
			const Element = LayerTree.GetElement(LayerName+'.Thumbnail');
			if ( Element )
			{
				Element.src = ImageUrl;
			}
			else
			{
				if ( TreeJson[LayerName].Thumbnail )
					TreeJson[LayerName].Thumbnail.src = ImageUrl;
				TreeJson[LayerName].src = ImageUrl;
				JsonChanged = true;
			}
		}
		
		if ( JsonChanged )
			LayerTree.json = TreeJson;
	}
	
	async function RenderThread()
	{
		let FrameTimeMs = 0;
		while ( IsThisProjectActive() )
		{
			//FrameTimeMs += 1000/60;
			FrameTimeMs += 16;
			//let ReadBackPixels = (FrameTimeMs % (10*16)) == 0;
			let ReadBackPixels = true;
			await LayerManager.Render( FrameTimeMs, ReadBackPixels ? OnLayerImage : null );
		}
	}
	SaveLayerManagerThread();
	await RenderThread();
	
	//	app has changed to new project
	LayerManager.Free();
	SetProjectButtonActive( ProjectName, false );
}

async function AppStartup()
{
	//	load old project
	const ProjectNames = await GetProjectNames();
	UpdateProjectButtons( ProjectNames );
	if ( ProjectNames.length > 0 )
	{
		LayerManagerThread( ProjectNames[0] );
	}
	else
	{
		LayerManagerThread(`First Project`);
	}
}
AppStartup();


</script>

</body>
</html>
