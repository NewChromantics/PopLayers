<html>
<head>
<title>Pop Layers</title>
<style>

canvas
{
	width:	256px;
	height:	256px;
}


body
{
	background:	#eee;
	padding:	1em;

	/* stretch grid to fill */
	height:		100vh;
	margin:		0px;
	overflow:	hidden;
	
	display:	grid;
	grid-template-areas:	"DropZone DropZone"
							"Error Error"
							"Progress Progress"
							"InputVideo OutputDepth"
							;
	grid-template-columns:	0.5fr 0.5fr;
	grid-template-rows:		0.4fr 0.0fr 0.1fr 0.5fr;
	align-items:		normal;
	justify-items:		normal;
}


#DropZone *
{
	display:	block;
}

#DropZone span
{
	pointer-events:	none;
}

#DropZone
{
	grid-area:	DropZone;
	border:		dashed 1px #000;
	padding:	1em;
	background:	#fff;
	
	display:	grid;
	align-items:		center;
	justify-items:		center;
}

#Progress
{
	grid-area:	Progress;
	background:	#ff0;
	padding:	1em;
}

#InputVideo
{
	grid-area:	InputVideo;
	background:	#efe;
	padding:	1em;
}

#OutputDepth
{
	grid-area:	OutputDepth;
	background:	#ffe;
	padding:	1em;
}

#Error,
#Info
{
	display:	block;
	grid-area:	Error;
	background:	#d33;
	color:		#fff;
	border:		1px solid #fff;
	padding:	0.5em;
	margin:		1em;
}

#Info
{
	grid-area:	Info;
	background:	#3d3;
}

#Error:empty,
#Info:empty
{
	display:	none;
}

</style>

</head>
<body>

<script>
	var QueueNewVideoFunction = function(){	throw `QueueNewVideoFunction not assigned`;	};
	
	function LoadCatMp4()
	{
		QueueNewVideoFunction(`Cat2.mp4`);
	}
	
	function SetProgress(FrameCompleted,FrameCount)
	{
		const Div = document.querySelector(`#Progress`);
		const Text = `${FrameCompleted}/${FrameCount}`;
		Div.innerText = Text;
	}
	
	function OnError(Error)
	{
		const Div = document.querySelector(`#Error`);
		const Text = Error ? `${Error}` : '';
		Div.innerText = Text;
	}		
	
</script>

<div id=DropZone>
	<span>Drop .mp4 Here</span>
	<button onclick="LoadCatMp4()">Load Cat.mp4</button>
</div>
<div id=Error></div>
<div id=Progress>0/0</div>

<canvas id=InputVideo width=256 height=256></canvas>
<canvas id=OutputDepth width=256 height=256></canvas>


<script type="module">

import {GenerateDepth} from './GenerateDepth/GenerateDepth.js'
import {VideoDecoder} from './PopEngine/Video.js'

function GetImageDataFromHtmlImageElement(Img,UseCanvas,OutputSize)
{
	function GetPixelsMetaFromHtmlImageElement(Img)
	{
		const Meta = {};
		Meta.Width = Img.videoWidth || Img.width || Img.displayWidth;
		Meta.Height = Img.videoHeight || Img.height || Img.displayHeight;
		Meta.Format = 'RGBA';
		return Meta;
	}

	//	html5 image
	//if ( Img.constructor == WebApi_HtmlImageElement )
	{
		//	gr: is this really the best way :/
		const Canvas = UseCanvas || document.createElement('canvas');
		const Context = Canvas.getContext('2d');
		const ImgMeta = GetPixelsMetaFromHtmlImageElement(Img);
		const Width = OutputSize ? OutputSize[0] : ImgMeta.Width;
		const Height = OutputSize ? OutputSize[1] : ImgMeta.Height;
		Canvas.width = Width;
		Canvas.height = Height;
		//	stretch to fill canvas
		Context.drawImage( Img, 0, 0, Canvas.width, Canvas.height );
		const ImageData = Context.getImageData(0, 0, Width, Height);
		
		if ( !UseCanvas )
		{
			//	destroy canvas (safari suggests its hanging around)
			Canvas.width = 0;
			Canvas.height = 0;
			//delete Canvas;	//	not allowed in strict mode
			//Canvas = null;
		}
		
		return ImageData;
	}
}


function GetPixelsFromHtmlImageElement(Img,UseCanvas)
{
	const ImageData = GetImageDataFromHtmlImageElement(Img,UseCanvas);
	
	const Buffer = ImageData.data;
		
	const Pixels = {};
	Pixels.Width = Width;
	Pixels.Height = Height;
	Pixels.Buffer = Buffer;
	//	gr: I checked pixels manually, canvas is always RGBA [in chrome]
	Pixels.Format = 'RGBA';
		
	return Pixels;
}

async function DrawToCanvas(Canvas,Image)
{
	const Context = Canvas.getContext('2d');

	if ( Image instanceof ImageData )
	{
		Context.putImageData( Image, 0, 0 );
	}
	else
	{
		let Width = Canvas.width || Image.width || Image.displayWidth;
		let Height = Canvas.height || Image.height || Image.displayHeight;
		//	stretches!
		Context.drawImage( Image, 0, 0, Width, Height );
	}
}

async function GenerateDepthAndDrawToCanvas(Canvas,Image)
{
	const Depth = await GenerateDepth(Image);
	
	//	turn depth data into rgba buffer for canvas	
	const Context = Canvas.getContext('2d');
	const RgbaPixels = Context.createImageData( Depth.Width, Depth.Height );
	function DepthPixelToDepthRgba(p,Index)
	{
		p -= Depth.MinValue;
		p /= Depth.MaxValue - Depth.MinValue;
		p *= 255;
		const Rgba = [p,p,p,255];
		const RgbaIndex = Index * 4;
		RgbaPixels.data[RgbaIndex+0] = Rgba[0];
		RgbaPixels.data[RgbaIndex+1] = Rgba[1];
		RgbaPixels.data[RgbaIndex+2] = Rgba[2];
		RgbaPixels.data[RgbaIndex+3] = Rgba[3];
	}
	Depth.Pixels.forEach( DepthPixelToDepthRgba );
	
	await DrawToCanvas(Canvas,RgbaPixels);
	
	return RgbaPixels;
}

import {FetchArrayBufferStream,WriteToFile} from './PopEngine/FileSystem.js'
import {CreatePromise} from './PopEngine/PromiseQueue.js'
import {GetNaluMeta,SplitNalus} from './PopEngine/H264.js'
import {Mp4FragmentedEncoder} from './PopEngine/Mp4.js'
import {DataWriter} from './PopEngine/DataReader.js'


async function VideoThread(VideoUrl)
{
	const Video = new VideoDecoder( VideoUrl );
	const OutputCanvas = document.querySelector(`#OutputDepth`);
	const InputCanvas = document.querySelector(`#InputVideo`);

	const ErrorPromise = CreatePromise();
	let OutputMp4Encoder = new Mp4FragmentedEncoder();
	let OutputVideoEncoder;

	function OnFrameEncoded(EncodedVideoChunk,StreamMetaData)
	{
		const TrackId = 1;
		if ( StreamMetaData && StreamMetaData.decoderConfig )
		{
			const Meta = StreamMetaData.decoderConfig;
			const Codec = Meta.codec;
			const ColourSpace = Meta.colorSpace;
			const ExtraDataSpsPps = Meta.description;
			console.log(`StreamMetaData`,StreamMetaData);
			OutputMp4Encoder.PushExtraData( ExtraDataSpsPps, TrackId );
		}
		const Bytes = new Uint8Array( EncodedVideoChunk.byteLength );
		const TimeMs = EncodedVideoChunk.timestamp / 1000;
		EncodedVideoChunk.copyTo( Bytes );
		console.log(`Encoded frame x${Bytes.length} @${TimeMs}`,EncodedVideoChunk);
		OutputMp4Encoder.PushSample( Bytes, TimeMs, TimeMs, TrackId );
		try
		{
			const Packets = SplitNalus(Bytes);
			const Metas = Packets.map( GetNaluMeta );
			Metas.forEach( m => console.log(`Encoded packet:`,m) );
		}
		catch(e)
		{
			console.warn(`Nalu error: ${e}`);
		}
	}
	function OnEncodingError(Error)
	{
		console.error(`Encoding error ${Error}`);
		ErrorPromise.Reject(Error);
	}

	async function GetVideoEncoder(Image)
	{
		if ( !OutputVideoEncoder )
		{
			//	gr: could do this on first frame output
			const EncoderParams = {};
			EncoderParams.output = OnFrameEncoded;
			EncoderParams.error = OnEncodingError;
			OutputVideoEncoder = new VideoEncoder(EncoderParams);
			
			const EncoderConfig = {};
			EncoderConfig.codec = 'avc1.42E01E';	//	todo: construct properly
			EncoderConfig.width = Image.width;
			EncoderConfig.height = Image.height;
			//EncoderConfig.bitrate = 8_000_000;	// 8 Mbps
			//EncoderConfig.framerate = 30;
			EncoderConfig.optimizeForLatency = true;
			await OutputVideoEncoder.configure(EncoderConfig);
		}
		return OutputVideoEncoder;
	}
	
	async function OutputFrame(Image,TimeMs)
	{
		const Encoder = await GetVideoEncoder(Image);
		const TimeMicro = TimeMs * 1000;
		const FrameMeta = {};
		//FrameMeta.duration = //	microsecs
		FrameMeta.timestamp = TimeMicro;//	microsecs
		
		//	for array buffer
		/*
		FrameMeta.format = 
		"I420"
		"I420A"
		"I422"
		"I444"
		"NV12"
		"RGBA"
		"RGBX"
		"BGRA"
		"BGRX"
		*/
		const Bitmap = await createImageBitmap(Image);
		const Frame = new VideoFrame( Bitmap, FrameMeta );
		Encoder.encode( Frame );
		Frame.close();
	}

	async function DownloadThread()
	{
		function OnProgress(Chunks)
		{
			const LastChunk = Chunks.slice(-1)[0];
			Video.PushData(LastChunk);
		}
		await FetchArrayBufferStream(VideoUrl,OnProgress);
		Video.PushEndOfFile();
	}
	DownloadThread();

	//	wait for meta so we know how many frames exist
	const Meta = await Video.WaitForVideoMetaChange();
	let FrameCount = Meta.Samples.length;
	SetProgress(0,FrameCount);
	
	async function MetaChangedThread()
	{
		while ( true )
		{
			const Meta = await Video.WaitForVideoMetaChange();
			FrameCount = Meta.Samples.length;
		}
	}
	//	keep watching for new meta
	MetaChangedThread();
		

	while ( true )
	{
		const NextFramePromise = Video.WaitForNextFrame();
		const NextFrame = await Promise.any([NextFramePromise,ErrorPromise]);
		if ( !NextFrame )
			break;
		//await DrawToCanvas( InputCanvas, NextFrame.Data );
		const OutputSize = [256,256];
		const FramePixels = GetImageDataFromHtmlImageElement( NextFrame.Data, null, OutputSize );
		await DrawToCanvas( InputCanvas, FramePixels );
		const DepthPixels = await GenerateDepthAndDrawToCanvas( OutputCanvas, FramePixels );
		//const DepthPixels = FramePixels;
		let FrameTimeMs = NextFrame.TimeMs || (NextFrame.FrameIndex*30);
		
		await OutputFrame( DepthPixels, FrameTimeMs );
		SetProgress( NextFrame.FrameIndex, FrameCount );
		//OutputVideo.encode(DepthPixels);
		
		if ( NextFrame.Free )
			NextFrame.Free();
		else if ( NextFrame.Data.Free )
			NextFrame.Data.Free();
	}
	
	//	wait for encoder to finish
	await OutputVideoEncoder.flush();
	OutputMp4Encoder.PushEndOfFile();
	
	const Mp4Data = new DataWriter();
	while ( true )
	{
		const Mp4Chunk = await OutputMp4Encoder.WaitForNextEncodedBytes();
		if ( !Mp4Chunk )
			break;
		Mp4Data.WriteBytes( Mp4Chunk );
	}
	const FinalMp4Data = Mp4Data.GetData();
	WriteToFile("Output.mp4", FinalMp4Data);
}

//	assign the function in the synchornous script
window.QueueNewVideoFunction = function(VideoUrl)
{
	//	todo: stop old thread
	window.OnError();
	VideoThread(VideoUrl).catch( window.OnError );
}

</script>

</body>
</html>
